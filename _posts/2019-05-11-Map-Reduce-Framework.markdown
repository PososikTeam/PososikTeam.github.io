---
layout: post
categories: blog2
---

{% highlight java %}
{% endhighlight %}

<div class="my_text">
В предыдущей статье была расмотрена общая схема Map-Reduce. Что делать
если мы столкнулись с конкретной задачей? Нужно обеспечить выполнение всех
свойств Мастера: создать директории ввода вывода, создать задачи бля мап
и редюс обеспечить контроль и т.д. Но существуют много готовых решений (один из
 наиболее богатых это фреймворк Hadoop) которые
берут на себя эту функциональность и вот за что они отвечают:
</div>
<img src="/assets/images/MapReduce-08.jpg" class="center">
<div class="my_text">
Для пользователя осталось написать функцию мап и редюс. <br>
Hadoop отвечет за выполнение MapReduce задач:
<ul>
   <li>Подготовка данных, разбиение данных на сплиты и донесение их до воркеров</li>
   <li>Планирование ресурсов(определяет на каких серверах есть свободные ресурсы и на них запускает задачи)</li>
   <li>Передача между этапом мапа и редюса(синхронным образом, нельзя запускать задачу редюса пока все мапы не завершились). Cледит за ошибками 
   в маппере, если произошла обишка перезапускает его и т.д.</li>
    <li>Всё это работает поверх HDFS в Hadoop, ничего не теряется. Кроме того при запуске задачи поверх HDFS 
    достаточно легко произвести спилование(один сплит равен одному блоку и удобно произвести  data_locality - обработка на том
     сервере где лежат данные) </li>
 
  </ul>
</div>
Демоны в Map-Reuce
<img src="/assets/images/MapReduce-09.jpg" class="center">
<div class="my_text">
В Map-Reduce существуют 2 типа демонов:
<ul>
<li>Jobtracker - главный процесс, отвечает за запуск задачи</li>
<li>Tasktracker - запущен на машине кластера и отвечает за запуск конкретных воркеров.(Как и Namenode запускается на отдельном сервере для стабильности работы)</li>
<li>Tasktracker  взаимодействует только с Jobtracker, с другими Tasktracker он не связывается.</li>
</ul>
Tasktracker и datanode обычно лежат вместе для осуществления datalocality.
</div>

Jobtracker
<img src="/assets/images/MapReduce-10.jpg" class="center">
<br>
Tasktracker
<img src="/assets/images/MapReduce-11.jpg" class="center">
<div class="my_text">
Слоты - лежат на каждом тасктрекере и таски запускаются на одном слоте
т.е количество слотов определяют количество воркеров которые могут быть запущены 
на данном сервере. Число слотов определяется из мощности сервера.
<br>
Пусть имеется машина с 16 ядер и 64 Gb ОЗУ, тогда можно выделить 16 слотов
по 4 Gb ОЗУ, но на самом деле  это не так, потому что в имеются ещё другие процессы
например datanode и по итогу мы сможем выделить только 14 слотов по 4 Gb ОЗУ.
<br>
Слоты делятся на мап слоты и редюс слоты.

</div>
<img src="/assets/images/MapReduce-12.jpg" class="center">

<div class="my_text">
Пример работы Map-Reduce. На условной задаче подсчёта числа слов в файле (Word count).
Делим файл на сплиты k1 - номер строки, v1 - сама строка с номером k1. Далее идёт маппер
считается количество слов в строке и пишется (слово a встретился 1 раз и слово b встретилось 2 раза в ПЕРВОМ МАППЕРЕ)
Ключь и значение у сплита и у маппера могут изменятся!
</div>
<img src="/assets/images/MapReduce-13.jpg" class="center">
<div class="my_text">
Далее маппер передаёт в один редюсер все значения одного ключа. Редюс подсчитывает и выводит результат.
</div>
<img src="/assets/images/MapReduce-14.jpg" class="center">

<div class="my_text">
Схема может изменится с дабовлением комбайна - это функция позволяющая упростить данные на этапе маппера. Стоит обратить внимание, что 
входные данные для комбайна будут ключи и значения НЕ ВСЕЙ ЗАДАЧИ, А ТОЛЬКО ОДНОГО МАППЕРА!
В данной задаче комбайн складывает значения одинаковых ключей на своих мапперах
<br>
Partition - определяет по ключу в какой релюсер его нужно отправить. (Можем определить что два ключа отправляются в один
редюсер, можем определить что ключь a отправляется в третий редюсер)
</div>
<img src="/assets/images/MapReduce-15.jpg" class="center">

<div class="my_text">
Понятно, что пользователю нужно реализовать функции мап и редюс.
</div>
<img src="/assets/images/MapReduce-16.jpg" class="center">

<div class="my_text">
Можно реализовать опциональную функцию partition, изначально это просто (hash mod n).
</div>
<img src="/assets/images/MapReduce-17.jpg" class="center">

<div class="my_text">
Можно реализовать опциональную функцию combine.
<br>
ВАЖНО! КОМБАЙНЕР МОЖЕТ НЕ ЗАПУСТИТСЯ ВООБЩЕ! И ПОЭТОМУ ЗАКЛАДЫВАТЬ ЛОГИКУ ПРИЛОЖЕНИЯ ОПИРАЯСЬ НА КОМБАЙНЕР НЕЛЬЗЯ!
ТАКЖЕ КОМБАЙНЕР НЕ ДОЛЖЕН МЕНЯТЬ ТИП КЛЮЧА И ЗНАЧЕНИЯ Т.К ЕСЛИ ОН НЕ ЗАПУСТИТСЯ, РЕЛЮС НЕ СМОЖЕТ ПРИНЯТЬ 
ТОТ ТИП ДАННЫХ КОТОРЫЙ ОТПРАВИЛ МАППЕР, ТАК КАК ОН ЖДАЛ ДАННЫЕ ОТ КОМБАЙНА.
</div>
<img src="/assets/images/MapReduce-18.jpg" class="center">